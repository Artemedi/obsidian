### Методы измерения производительности запросов  

Для того чтобы понять, на каких запросах следует сосредоточиться при их настройке, нам необходим метод точного измерения производительности запросов. Кроме того, по мере того как мы будем предпринимать различные попытки улучшить производительность запросов, нам необходимо уметь фиксировать метрики, которые позволят нам понять, насколько хорошо работают наши улучшения и работают ли они вообще. И, наконец, нам нужно уметь измерять результаты наших улучшений, чтобы подтвердить их эффективность и начать процесс заново, выявляя следующий плохо работающий запрос. Несмотря на то, что существует большое количество механизмов для определения производительности запросов, мы сосредоточим наши усилия на трех, которые, по моему мнению, являются наиболее точными и простыми в реализации.  
Хотя остальные механизмы тоже работают, я считаю, что эти три работают лучше всего. Если вы решите использовать другой механизм, просто будьте последовательны в том, что вы измеряете, потому что каждый инструмент сбора метрик, который я использовал, отличается от всех остальных.  
В этой главе мы узнаем о следующем  
  
- Использование динамических представлений управления  
- Сбор подробных метрик с помощью расширенных событий  
- Метрики производительности запросов в хранилище запросов  
#queryperformance

## Методы сбора метрик производительности запросов  
  
Существует большое количество способов сбора метрик запросов. Большинство из них одинаково точны, но некоторые либо проще в использовании, либо дают более полную информацию, либо лучше работают в масштабе больших систем. Позвольте мне пробежаться по всем возможным вариантам, а затем мы кратко обсудим, почему я не использую одни показатели так же часто, как другие. Ниже перечислены возможные методы измерения производительности запросов:  
  
- Включение статистики клиента  
- Свойства соединения  
- SET STATISTICS TIME/IO  
- QueryTimeStats в плане выполнения  
- Хранилище запросов  
- Представления динамического управления (DMVs)  
- События трассировки (Profiler)  
- Расширенные события  
  
Поскольку о DMVs, Query Store и Extended Events мы будем говорить в оставшейся части главы, я хочу рассказать об остальном прямо здесь. Начнем с единственного показателя, который на самом деле не является точным (в отличие от всех остальных), - Include Client Statistics.  
  
## Включить статистику клиентов 

Для этого нужно щелкнуть правой кнопкой мыши в окне запроса в SQL Server Management Studio (SSMS) и выбрать из контекстного меню пункт "Include Client Statistics". При этом будет фиксироваться время выполнения и ввод-вывод с клиента, на котором выполняется запрос. Это означает, что сетевое время, локальная борьба за ресурсы и все остальное негативно скажется на измерении производительности. Вывод этих значений никак не совпадает с результатами других методов. В связи с этим я просто никогда не использую этот метод.  
#ClientStatistics

## Свойства соединения  
  
Этот метод на самом деле очень удобен, хотя я не использую его в качестве основной меры. Перед выполнением запроса или даже после него щелкните правой кнопкой мыши в окне запроса в SSMS и выберите в контекстном меню пункт "Свойства". В результате откроется окно Properties (которое мы будем часто использовать с планами выполнения на протяжении всей книги; я обычно оставляю это окно открытым и доступным все время работы). В нем вы найдете информацию "Детали соединения". Эта информация включает в себя "Время, прошедшее с момента подключения", которое на самом деле является точным показателем производительности запроса. Хотя в SSMS производительность запроса можно увидеть в нижней части экрана, она измеряется только с точностью до секунды.  
Здесь же значения точны до миллисекунд. Единственная проблема заключается в том, что он не дает нам измерения ввода/вывода, поэтому он не так полезен, как другие измерения, которые дают нам и прошедшее время, и ввод/вывод, и, в некоторых случаях, использование процессора. Однако если вы забудете включить какой-либо другой механизм сбора данных, то этот всегда будет доступен, что, опять же, делает его очень удобным.
#ConnectionProperties
  
## SET STATISTICS TIME/IO  
  
Это классический механизм измерения производительности при настройке запросов. В предыдущих версиях книги эти значения широко использовались. Они точны, поэтому если вы решите их использовать, то все будет в порядке. Их можно использовать, зайдя в Options для SSMS, щелкнув правой кнопкой мыши и выбрав их из контекстного меню, или используя T-SQL для SET STATISTICS TIME ON (что делает этот механизм удобным и в Azure Data Studio).  
Позвольте мне объяснить, почему я больше не использую их. Во-первых, вы получаете только одно измерение. Я обнаружил, что получаю более точные результаты, если выполняю запрос несколько раз, а затем усредняю результаты. Это очень трудно сделать с помощью данного измерения. Вы также не получаете данных об использовании процессора. Наконец, если вы фиксируете TIME и IO с помощью этого метода, то фиксация IO может негативно повлиять на фиксацию TIME, сделав ее менее точной. Обычно это заметно только для запросов, выполняющихся менее секунды или даже менее 100 миллисекунд. Тем не менее, когда точность нужна больше всего, приходится настраиваться на последние несколько миллисекунд. Отсутствие такой точности снижает полезность этого механизма.  
#SETSTATISTICS

## QueryTimeStats в Плане выполнения  
  
При захвате метрик времени выполнения с планом выполнения, который в SSMS, начиная с 2016 года, называется "Фактический план выполнения", вы получаете метрики времени выполнения запроса, включая статистику ожидания. Это точные измерения, которые являются частью плана выполнения. Я обязательно буду их использовать. Однако, опять же, они отображаются только для одного выполнения, что затрудняет получение средних значений. Кроме того, захват планов выполнения негативно сказывается на измерении времени, поскольку захват метрик времени выполнения вместе с планом выполнения замедляет выполнение запроса. По этой причине, когда мне нужны точные показатели производительности, я не беру планы выполнения. Этот простой факт означает, что я не могу полагаться на этот показатель постоянно.  
  
## Трассировка событий (Profiler)  
  
Это может быть болезненной темой. Многие опытные специалисты по работе с данными уже давно работают с Trace Events и Profiler (графический интерфейс пользователя для работы с данными Trace Event). Использование этих инструментов для них комфортно, они приобрели отличные навыки работы с ними и не собираются останавливаться. Я не собираюсь стоять у них на пути. Однако по ряду причин я не буду пропагандировать использование Trace Events, и если вы только начинаете заниматься настройкой производительности запросов, я настоятельно рекомендую не использовать их.  
Во-первых, Trace Events очень дороги в операционной системе SQL Server. В отличие от Extended Events, которые, начиная с SQL Server 2008, были включены непосредственно во внутреннее поведение SQL Server, Trace Events были созданы и реализованы отдельно. Это приводит к тому, что они занимают больше памяти и процессора, чем Extended Events.  
Из-за того, что Trace Events собирают информацию, они не могут быть отфильтрованы при захвате, как Extended Events. Это означает, что все ресурсы, необходимые для захвата события, расходуются, но затем происходит фильтрация, и это событие удаляется из результатов.  
Другая проблема связана с графическим интерфейсом Profiler. Если вы подключаете графический интерфейс Profiler к событию Trace Event на действующем сервере, он создает на нем дополнительное пространство памяти и использует его для потребления событий в реальном времени, что приводит к нехватке ресурсов в системе.  
Наконец, способ потребления данных в Trace Events не так эффективен, как это можно сделать с помощью окна Live Data Explorer в Extended Events.  
По всем этим причинам я не буду использовать Trace Events для сбора информации в системе SQL Server 2012 и выше. До 2012 года Trace Events по-прежнему является предпочтительным механизмом.  
#profiler
