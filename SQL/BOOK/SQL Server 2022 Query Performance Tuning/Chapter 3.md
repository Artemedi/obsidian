### Методы измерения производительности запросов  

Для того чтобы понять, на каких запросах следует сосредоточиться при их настройке, нам необходим метод точного измерения производительности запросов. Кроме того, по мере того как мы будем предпринимать различные попытки улучшить производительность запросов, нам необходимо уметь фиксировать метрики, которые позволят нам понять, насколько хорошо работают наши улучшения и работают ли они вообще. И, наконец, нам нужно уметь измерять результаты наших улучшений, чтобы подтвердить их эффективность и начать процесс заново, выявляя следующий плохо работающий запрос. Несмотря на то, что существует большое количество механизмов для определения производительности запросов, мы сосредоточим наши усилия на трех, которые, по моему мнению, являются наиболее точными и простыми в реализации.  
Хотя остальные механизмы тоже работают, я считаю, что эти три работают лучше всего. Если вы решите использовать другой механизм, просто будьте последовательны в том, что вы измеряете, потому что каждый инструмент сбора метрик, который я использовал, отличается от всех остальных.  
В этой главе мы узнаем о следующем  
  
- Использование динамических представлений управления  
- Сбор подробных метрик с помощью расширенных событий  
- Метрики производительности запросов в хранилище запросов  
#queryperformance

## Методы сбора метрик производительности запросов  
  
Существует большое количество способов сбора метрик запросов. Большинство из них одинаково точны, но некоторые либо проще в использовании, либо дают более полную информацию, либо лучше работают в масштабе больших систем. Позвольте мне пробежаться по всем возможным вариантам, а затем мы кратко обсудим, почему я не использую одни показатели так же часто, как другие. Ниже перечислены возможные методы измерения производительности запросов:  
  
- Включение статистики клиента  
- Свойства соединения  
- SET STATISTICS TIME/IO  
- QueryTimeStats в плане выполнения  
- Хранилище запросов  
- Представления динамического управления (DMVs)  
- События трассировки (Profiler)  
- Расширенные события  
  
Поскольку о DMVs, Query Store и Extended Events мы будем говорить в оставшейся части главы, я хочу рассказать об остальном прямо здесь. Начнем с единственного показателя, который на самом деле не является точным (в отличие от всех остальных), - Include Client Statistics.  
  
## Включить статистику клиентов 

Для этого нужно щелкнуть правой кнопкой мыши в окне запроса в SQL Server Management Studio (SSMS) и выбрать из контекстного меню пункт "Include Client Statistics". При этом будет фиксироваться время выполнения и ввод-вывод с клиента, на котором выполняется запрос. Это означает, что сетевое время, локальная борьба за ресурсы и все остальное негативно скажется на измерении производительности. Вывод этих значений никак не совпадает с результатами других методов. В связи с этим я просто никогда не использую этот метод.  
#ClientStatistics

## Свойства соединения  
  
Этот метод на самом деле очень удобен, хотя я не использую его в качестве основной меры. Перед выполнением запроса или даже после него щелкните правой кнопкой мыши в окне запроса в SSMS и выберите в контекстном меню пункт "Свойства". В результате откроется окно Properties (которое мы будем часто использовать с планами выполнения на протяжении всей книги; я обычно оставляю это окно открытым и доступным все время работы). В нем вы найдете информацию "Детали соединения". Эта информация включает в себя "Время, прошедшее с момента подключения", которое на самом деле является точным показателем производительности запроса. Хотя в SSMS производительность запроса можно увидеть в нижней части экрана, она измеряется только с точностью до секунды.  
Здесь же значения точны до миллисекунд. Единственная проблема заключается в том, что он не дает нам измерения ввода/вывода, поэтому он не так полезен, как другие измерения, которые дают нам и прошедшее время, и ввод/вывод, и, в некоторых случаях, использование процессора. Однако если вы забудете включить какой-либо другой механизм сбора данных, то этот всегда будет доступен, что, опять же, делает его очень удобным.
#ConnectionProperties
  
## SET STATISTICS TIME/IO  
  
Это классический механизм измерения производительности при настройке запросов. В предыдущих версиях книги эти значения широко использовались. Они точны, поэтому если вы решите их использовать, то все будет в порядке. Их можно использовать, зайдя в Options для SSMS, щелкнув правой кнопкой мыши и выбрав их из контекстного меню, или используя T-SQL для SET STATISTICS TIME ON (что делает этот механизм удобным и в Azure Data Studio).  
Позвольте мне объяснить, почему я больше не использую их. Во-первых, вы получаете только одно измерение. Я обнаружил, что получаю более точные результаты, если выполняю запрос несколько раз, а затем усредняю результаты. Это очень трудно сделать с помощью данного измерения. Вы также не получаете данных об использовании процессора. Наконец, если вы фиксируете TIME и IO с помощью этого метода, то фиксация IO может негативно повлиять на фиксацию TIME, сделав ее менее точной. Обычно это заметно только для запросов, выполняющихся менее секунды или даже менее 100 миллисекунд. Тем не менее, когда точность нужна больше всего, приходится настраиваться на последние несколько миллисекунд. Отсутствие такой точности снижает полезность этого механизма.  
#SETSTATISTICS

## QueryTimeStats в Плане выполнения  
  
При захвате метрик времени выполнения с планом выполнения, который в SSMS, начиная с 2016 года, называется "Фактический план выполнения", вы получаете метрики времени выполнения запроса, включая статистику ожидания. Это точные измерения, которые являются частью плана выполнения. Я обязательно буду их использовать. Однако, опять же, они отображаются только для одного выполнения, что затрудняет получение средних значений. Кроме того, захват планов выполнения негативно сказывается на измерении времени, поскольку захват метрик времени выполнения вместе с планом выполнения замедляет выполнение запроса. По этой причине, когда мне нужны точные показатели производительности, я не беру планы выполнения. Этот простой факт означает, что я не могу полагаться на этот показатель постоянно.  
  
## Трассировка событий (Profiler)  
  
Это может быть болезненной темой. Многие опытные специалисты по работе с данными уже давно работают с Trace Events и Profiler (графический интерфейс пользователя для работы с данными Trace Event). Использование этих инструментов для них комфортно, они приобрели отличные навыки работы с ними и не собираются останавливаться. Я не собираюсь стоять у них на пути. Однако по ряду причин я не буду пропагандировать использование Trace Events, и если вы только начинаете заниматься настройкой производительности запросов, я настоятельно рекомендую не использовать их.  
Во-первых, Trace Events очень дорогостоящая операция для операционной системы SQL Server. В отличие от Extended Events, которые, начиная с SQL Server 2008, были включены непосредственно во внутреннюю модель SQL Server, Trace Events были разработаны и внедрены отдельно. Это приводит к тому, что они занимают больше памяти и процессора, чем Extended Events. 
Из-за того, что Trace Events собирают информацию, их нельзя отфильтровать на этапе захвата, как в случае Extended Events. Это означает, что все необходимые для захвата события ресурсы используются, а затем происходит фильтрация и это событие удаляется из результатов.
Другая проблема связана с графическим интерфейсом Profiler. Если подключить Profiler GUI к Trace Events на рабочем сервере, то он создает на нем дополнительное пространство памяти и использует его для обработки событий в реальном времени, что приводит к сокращению ресурсов системы.
Наконец, использование данных в Trace Events не так эффективно, как это можно сделать с помощью окна Live Data Explorer в Extended Events.
По всем этим причинам на системах с SQL Server 2012 и выше я не буду использовать Trace Events для сбора информации. До 2012 года Trace Events по-прежнему является предпочтительным механизмом.
#profiler

## Представления динамического управления  

Существует очень большое количество DMV. Даже если мы ограничимся рассмотрением DMV, связанных с производительностью запросов, их все равно будет очень много. Поэтому я не буду пытаться описать их все и способы их использования. Вместо этого мы рассмотрим здесь основные DMV, связанные с производительностью запросов, а о дополнительных DMV мы будем говорить на протяжении всей книги (некоторые из них мы представили в главе 2).  
DMV делятся на две большие категории: для запросов, выполняющихся в данный момент, и для запросов, которые были выполнены ранее. Информация, собранная для ранее выполненных запросов, полностью зависит от кэша. Если по какой-либо причине запрос устарел или был принудительно удален из кэша, то все метрики запроса уходят вместе с ним. Кроме того, информация о ранее выполненных запросах является только агрегированной. Вы не сможете отличить запрос, выполненный в 2 часа ночи, от того же запроса, выполненного в 3 часа ночи, если только не воспользуетесь DMV для сбора метрик в оба времени.  
обоих случаях.  
Я часто использую DMV для метрик запросов по нескольким причинам. Во-первых, большинство из них доступны во всех версиях SQL Server, начиная с 2005 года и выше, включая AWS RDS и Azure SQL Database. Это означает, что у меня всегда есть возможность получить метрики производительности запросов. Во-вторых, не всегда на сервере будут постоянно включены другие методы. Некоторые базы данных могут иметь слишком высокую нагрузку для работы Query Store. Хотя Extended Events очень легки, они не бесплатны, поэтому они тоже не будут запущены всегда.  
Тем не менее, я всегда смогу взглянуть на метрики запросов через DMV.  
Давайте сначала рассмотрим, как можно перехватывать активно выполняющиеся запросы. 
#dvm

## Запросы с активным выполнением

Важно воспринимать DMV как строительные блоки или лего. Их можно собирать по-разному. Однако есть несколько отправных точек, к которым вы всегда будете возвращаться. Для запросов, которые находятся в активном выполнении, отправной точкой чаще всего является sys.dm_exec_requests. Этот DMV собирает огромное количество информации об исполняющихся запросах, включая следующие сведения:  
  
- Starttime: Когда запрос начал выполняться  
- Command Type: Какой это тип запроса  
- Plan_handle: Используется для получения плана выполнения из кэша  
- Sql_handle: Используется для получения текста T-SQL из кэша  
- Blocking_session_id: Если процесс заблокирован, то какая сессия его блокирует  
- Wait_type: Если процесс ожидает, то чего он ожидает  
- Total_elapsed_time: Сколько времени выполняется процесс  
- Cpu_time: Сколько процессора было потреблено процессом  
- Reads: Сколько чтений было выполнено этим процессом  
- Writes: Сколько записей было произведено этим процессом.  
  
Существует еще больше полезной информации, но общее представление вы получили.  
Чтобы действительно использовать DMV для получения интересной информации, нам потребуется объединить его с несколькими другими DMV. Первая - sys.dm_exec_query_plan(), которая содержит все планы выполнения, находящиеся в кэше планов. Вторая - sys.dm_exec_sql_text(), которая содержит пакетный текст T-SQL для выполняемого запроса. В листинге 3-1 показан один из возможных способов комбинирования этих DMV для получения полезных метрик запроса для выполняющихся в данный момент запросов.  
  
Листинг 3-1. Комбинирование sys.dm_exec_requests с другими DMV
```sql
SELECT  dest.text,
		deqp.query_plan,
		der.cpu_time,
		der.logical_reads,
		der.writes
FROM sys.dm_exec_requests AS der
	CROSS APPLY sys.dm_exec_query_plan(der.plan_handle) AS deqp
	CROSS APPLY sys.dm_exec_sql_text(der.plan_handle) AS dest;
```

Вы можете использовать гораздо более сложные запросы к этим DMV, например возвращать отдельные данные, а не целые пакеты, отфильтровывать session_id для самого запроса и многое другое. Однако этого вполне достаточно для начала работы.