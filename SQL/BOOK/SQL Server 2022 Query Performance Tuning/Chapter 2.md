## Генерация плана выполнения и оптимизатор запросов

Вся производительность SQL Server начинается и часто заканчивается оптимизатором запросов. Поскольку оптимизатор очень важен для производительности запросов, мы сразу же рассмотрим его поведение, чтобы лучше понять, почему наши запросы ведут себя так, как они ведут. Результатом процесса оптимизации является план выполнения - механизм, показывающий, какой выбор был сделан оптимизатором. Процесс оптимизации требует больших затрат ресурсов, особенно процессора, и может занимать некоторое время, влияя на время выполнения запросов. Мы рассмотрим, что представляет собой этот процесс, как формируется план выполнения и как этот план попадает в память в кэш планов в надежде на повторное использование плана.

В этой главе мы рассмотрим следующие вопросы:  
- Процесс оптимизации запросов в целом  
- Планы выполнения и кэш планов  
- Факторы, влияющие на генерацию параллельных планов  

## Процесс оптимизации запросов 

Оптимизатор запросов в SQL Server использует механизм анализа, основанный на затратах, для принятия решений, необходимых для удовлетворения запросов, которые вы отправили. Для того чтобы обработать запрос, необходимо принять большое количество решений. Какой индекс использовать для доступа к таблице, как объединить две таблицы, нужно ли упорядочивать данные - все это и многое другое оптимизатор оценивает по стоимости. Оптимизатор также знает о структуре базы данных. От типов данных в столбцах до определений первичных ключей, ограничений и внешних ключей - эти объекты также влияют на оценки стоимости, которые использует оптимизатор для принятия решений. Наконец, данные включаются в стоимость с помощью статистики о данных (более подробно рассматривается в главе 5). 
Как уже говорилось в главе 1, оптимизатор не пытается составить идеальный план выполнения. Вместо этого оптимизатор использует математические модели, частично основанные на объектах и статистике вашей базы данных, чтобы прийти к достаточно хорошему плану. Таким образом, анализ, основанный на затратах, пытается составить как можно более оптимальный план, используя при этом как можно меньше ресурсов и завершая работу как можно быстрее. 
Однако прежде чем приступить к оптимизации, необходимо выполнить несколько начальных, подготовительных этапов.

## Подготовка к оптимизации

Поскольку оптимизатору требуется большое количество метаданных о вашей системе, перед оптимизацией необходимо выполнить ряд действий, чтобы собрать эту информацию воедино. шагов перед началом оптимизации, чтобы собрать эту информацию воедино. Порядок выполнения этих шагов следующий:  
1. Парсинг  
2. Связь  
3. Оптимизация  
Существует сложный набор входов и выходов, который не нужно исследовать, чтобы понять, что происходит. чтобы понять суть происходящего. Однако для наглядности на рис. 2-1 показан процесс, входы и выходы:  

![[StepsLeadingUpToTheOptimizationProcess.png]]

Рассмотрим два этапа, которые предшествуют собственно процессу оптимизации процесса оптимизации.
## Парсинг 

Сначала запрос проходит через реляционный механизм SQL Server. Это первая часть двух процессов, которые работают с запросом. Вторым процессом является механизм хранения, который отвечает за доступ к данным, их модификацию и кэширование. ==Реляционный механизм выполняет разбор запроса с помощью процесса, называемого алгебризатором.== Реляционный движок выполняет запрос в соответствии со сформированным планом выполнения и запрашивает данные у хранилища.  
Алгебраизатор выполняет несколько шагов, но первым из них является разбор запроса. В процессе разбора просто проверяется правильность синтаксиса запроса. Если в синтаксисе есть ошибка, то процесс немедленно завершается, и все процессы оптимизации прерываются. Если несколько запросов подаются вместе как один пакет, то проверяется весь пакет, и в случае обнаружения синтаксической ошибки в любом месте пакета пакет отменяется. Хотя синтаксических ошибок может быть несколько, синтаксический анализатор останавливается на первой ошибке и прекращает всю остальную обработку. Немедленное прерывание - это лишь один из аспектов того, как оптимизатор пытается снизить накладные расходы на процесс оптимизации. В листинге 2-1 показан пакет с ошибкой.  

```sql
CREATE TABLE dbo.Example
(Col1 INT);

INSERT INTO dbo.Example
(Col1)
VALUES
(1);

SELECT e.Col1
FORM dbo.Example AS e; -- Generates an error because of 'FORM'
```

После завершения процесса синтаксического разбора создается внутренняя структура, называемая деревом разбора создается и передается на следующий шаг.
#parsing #Алгебризатор #algebrizator
## Связь  

Дерево разбора теперь используется для определения всех объектов, составляющих запрос. В этот список объектов входят таблицы, столбцы, индексы и многое другое. Этот процесс называется связыванием. Определяются все обрабатываемые типы данных. Определяются все виды агрегирования с помощью GROUP BY. Все эти объекты и процессы объединяются в другую внутреннюю структуру, называемую деревом процессора запросов(query processor tree).  
Алгебраизатор также будет обрабатывать неявные преобразования данных, добавляя шаги в дерево процессора. Также можно наблюдать оптимизацию синтаксиса, при которой фактически изменяется код, переданный SQL Server. Если взять код из листинга 2-2 и записать план выполнения (рассматривается в главе 4), то можно увидеть реальные изменения в синтаксисе.  

**Листинг 2-2.** Исходный код до связывания:

```sql
SELECT  soh.AccountNumber,
		soh.OrderDate,
		soh.PurchaseOrderNumber,
		soh.SalesOrderNumber
FROM Sales.SalesOrderHeader AS soh
WHERE soh.SalesOrderID
BETWEEN 62500 AND 62550;
```

На рис. 2-2 показано изменение синтаксиса:

![[Figure 2-2.png]]

Внесены два очень заметных изменения. Во-первых, оператор BETWEEN был было заменено на ">=" и "<=". Во-вторых, процесс, называемый простой параметризацией реализован с помощью символов @1 и @2, которые вы видите на рисунке. Подробнее о параметризации далее в этой главе. Еще одно подтверждение процесса связывания если мы посмотрим на план выполнения, сгенерированный на рис. 2-3.

![[Figure 2-3.png]]

Восклицательный знак на первом операторе слева, обозначенном как "SELECT", свидетельствует о предупреждении. Если посмотреть на свойства этого оператора, то можно обнаружить, что SalesOrderID фактически проходит через преобразование типа данных: 

``Type conversion in expression (CONVERT(nvarchar(23),[soh].[SalesOrderID],0)) may affect "CardinalityEstimate" in query plan choice``

Этот пример иллюстрирует несколько моментов, помимо оптимизации на основе синтаксиса. Во-первых, предупреждения иногда могут быть неясными. В данном случае предупреждение не связано со столбцом SalesOrderID, на который ссылается предложение WHERE запроса. Вместо этого предупреждение выдается из вычисляемого столбца SalesOrderNumber. Этот расчет преобразует целое число SalesOrderID в строку и добавляет к нему другую информацию. Оптимизатор понимает, что если бы это вычисление использовалось в качестве критерия фильтрации в предложении WHERE, или JOIN, или даже в предложении HAVING, то это повлияло бы на возможность использования статистики и индексов для достижения высокой производительности. Однако в данном случае запрос не ссылается на этот столбец ни в одном из критериев фильтрации, поэтому мы можем спокойно проигнорировать предупреждение. Мне нравится этот пример, потому что он показывает, насколько реалистичен AdventureWorks на самом деле. В реальных базах данных возникает множество подобных проблем. 
В отличие от запросов на языке манипулирования данными (DML), которые мы рассматривали до сих пор, запросы на языке определения данных (DDL), такие как CREATE TABLE, не имеют планов выполнения. В качестве примера можно привести только один способ выполнения запроса CREATE VIEW. Поэтому большинство DDL не проходят через процесс оптимизации. Исключение составляют DDL-запросы CREATE INDEX. Оптимизатор может использовать преимущества существующих индексов для более эффективного создания другого индекса. Поэтому, хотя вы никогда не увидите план выполнения CREATE PROCEDURE, вы можете увидеть его при создании индекса.  
После завершения всех операций связывания создается еще одна внутренняя структура, называемая деревом процессора запросов. Именно здесь начинается оптимизация.
#binding

## Оптимизация

Процесс оптимизации представляет собой довольно удивительное программное обеспечение. Без отладчика его невозможно увидеть в действии. Однако мы можем увидеть результаты этого процесса в создаваемых им планах выполнения. Мы также можем использовать динамические представления управления (DMV) и расширенные события для наблюдения за аспектами процесса оптимизации. В этой книге мы увидим множество свидетельств оптимизации, но изучение кода с помощью отладчика выходит за рамки книги. Мы ограничимся теми инструментами, которые нам сразу доступны. Начнем разговор о процессе оптимизации.  
На рис. 2-4 показаны процессы, которые использует оптимизатор для того, чтобы как можно быстрее прийти к "достаточно хорошему" плану выполнения.  

![[Figure 2-4.png]]

Обсудим каждый шаг, чтобы понять, как оптимизатор приходит к плану выполнения план выполнения.
#Optimization
## Упрощение 

Первым шагом в оптимизации является процесс, называемый упрощением. Здесь оптимизатор убеждается, что все объекты, на которые вы ссылаетесь в запросе, действительно используются. Начинается сбор и использование статистики и количества строк. На этом этапе рассматриваются ограничения, такие как внешние ключи. Когда все это вместе взято, можно увидеть, как оптимизатор фактически изменяет то, что обрабатывается. Например, можно написать запрос с объединением четырех таблиц. Однако в списке SELECT и в предложении WHERE имеются ссылки только на две таблицы. Используя ограничения, оптимизатор может определить, что две другие таблицы ему не нужны для выполнения запроса, и поэтому исключит их из дальнейшей обработки, упростив запрос - отсюда и название этого шага. 
#Simplification

## Подбор тривиального плана

Когда запрос предельно упрощен, он может соответствовать шаблону, для которого нет вариантов, а есть только один возможный план выполнения. Такая ситуация называется тривиальным планом. Простейшим примером является таблица без кластерного индекса, называемая кучей, и без других индексов. Единственный способ доступа к этой таблице - сканирование таблицы. Вместо того чтобы попытаться построить план выполнения, оптимизатор ищет шаблон запроса, который соответствует существующим тривиальным планам. При обнаружении совпадения с шаблоном оптимизация, являющаяся дорогостоящей операцией, полностью пропускается. Вместо этого для выполнения запроса используется тривиальный план. Как уже говорилось, тривиальные планы встречаются только в очень простых запросах. О том, что план помечен как тривиальный, можно судить по свойствам плана выполнения (рассматриваются в главе 4). 
#trivialplan

## Этапы оптимизации  

Как только становится ясно, что тривиальный план найти не удастся, оптимизатору приходится пройти несколько фаз оптимизации, чтобы попытаться получить достаточно хороший план выполнения. Он разбивает этот процесс на несколько этапов, на каждом из которых старается выполнить как можно меньше работы. Эти этапы называются

- Поиск 0 или Транзакция: Он называется транзакционным, поскольку типы запросов, которые могут быть здесь удовлетворены, обычно являются простыми запросами в стиле Online Transaction Processing (OLTP) с небольшим количеством объединений и отсутствием необходимости в преобразованиях. 
- Поиск 1 или Быстрый план: Здесь выполняются более сложные операции, такие как переупорядочивание соединений и другие преобразования для получения достаточно хорошего плана.  
- Поиск 2 или полная оптимизация: При сложных запросах они проходят все три этапа оптимизации, чтобы достичь полной оптимизации.  

В зависимости от запроса, его сложности и наличия вспомогательных объектов, таких как индексы и ограничения, оптимизатор может сократить эти этапы, перейдя сразу к Quick Plan или Full Optimization, пропустив Transaction. На каждом из этих этапов может быть принято решение о том, как выполнить ту или иную операцию JOIN или получить доступ к данным с помощью сканирования или поиска.  
Основным фактором, определяющим большинство решений, принимаемых оптимизатором, является количество строк. Количество строк обычно определяется статистикой столбцов в критериях фильтрации, таких как предикаты ON, HAVING и WHERE. Имея на руках статистику, оптимизатор начинает делать выбор и расчеты, основываясь на том, сколько примерно процессора, памяти и ввода-вывода необходимо для выполнения запроса. Эти оценки складываются в общую стоимость выполнения запроса. Эта стоимость не является показателем, основанным на вашей системе. Скорее, это произвольный расчет, выполняемый оптимизатором и являющийся чисто математической конструкцией.  
Оптимизатор рассчитывает количество итераций, которые ему необходимо выполнить, пробуя различные планы, используя различные стратегии. Одновременно он рассчитывает, какой план будет наименее затратным. Когда будет найден план, удовлетворяющий всем вычисленным требованиям, оптимизация прекращается, даже если может быть найден лучший план. Это называется досрочным прекращением оптимизации. Прекращение оптимизации можно также увидеть, когда оптимизатор пройдет расчетное количество итераций. В этот момент оптимизатор завершает оптимизацию по так называемому таймауту (подробнее об этом в главе 4).  
Если запрос достигает уровня Search 2, или Full Optimization, он также может быть оценен на предмет преобразования из последовательного плана в параллельный (подробнее об этом далее в главе).  
С помощью планов выполнения можно увидеть многое из того, что делает оптимизатор. В качестве примера рассмотрим запрос в Листинге 2-3.  
  
Листинг 2-3. Несколько усложненный запрос

```sql
SELECT  soh.SalesOrderNumber,
		sod.OrderQty,
		sod.LineTotal,
		sod.UnitPrice,
		sod.UnitPriceDiscount,
		p.Name AS ProductName,
		p.ProductNumber,
		ps.Name AS ProductSubCategoryName,
		pc.Name AS ProductCategoryName
FROM Sales.SalesOrderHeader AS soh
	JOIN Sales.SalesOrderDetail AS sod
		ON soh.SalesOrderID = sod.SalesOrderID
	JOIN Production.Product AS p
		ON sod.ProductID = p.ProductID
	JOIN Production.ProductModel AS pm
		ON p.ProductModelID = pm.ProductModelID
	JOIN Production.ProductSubcategory AS ps
		ON p.ProductSubcategoryID = ps.ProductSubcategoryID
	JOIN Production.ProductCategory AS pc
		ON ps.ProductCategoryID = pc.ProductCategoryID
WHERE soh.CustomerID = 29658;
```

Если мы возьмем план выполнения этого запроса (опять же, это будет рассмотрено в главе 4), то сможем увидеть некоторые особенности поведения оптимизатора. Этот план трудно читать в данном контексте, но я и не хочу, чтобы вы пытались понять его на данном этапе. План показан на рис. 2-5.

![[Figure 2-5.png]]

Не пытайтесь читать этот план. Он слишком мал. Вместо того чтобы сейчас читать план, мы сосредоточимся на одной точке - операторе в крайней левой части плана. В данном случае, поскольку это запрос SELECT, оператор обозначен как SELECT. Свойства этого оператора это вся информация о самом плане выполнения. К ним относится информация о процессе оптимизации. Подмножество этих свойств показано на рис. 2-6.  

![[Figure 2-6.png]]

Некоторые из отображаемых на экране данных включают следующее:  
- CompileCPU: Количество процессорного времени, затраченного на составление данного плана.  
- Estimated Number of Rows Per Execution: Количество строк, к которому пришел оптимизатор для данного запроса  
- Estimated Subtree Cost: Совокупная оценка затрат процессора, ввода-вывода и памяти, полученная в процессе оптимизации.  
Это лишь пример того, как оптимизатор работает над планом выполнения. Мы также можем обратиться к этим данным, чтобы увидеть такие вещи, как уровень оптимизации (Optimization Level) и причина досрочного завершения (Reason for Early Termination) - верхние и нижние свойства, показанные на рис. 2-7.  

![[Figure 2-7.png]]

Стоит отметить, что если мы видим свойство Optimization Level и значение "Full", то это не обязательно означает, что данный план прошел через Search 2, а только то, что это не тривиальный план.  
Другим способом наблюдения за работой оптимизатора является использование Представления Динамического Управления (DMV) sys.dm_exec_query_optimizer_info. Названный соответствующим образом, этот DMV показывает агрегированные данные о процессе оптимизации. Пример использования этого DMV приведен в листинге 2-4.  
  
Листинг 2-4. Запрос DMV dm_exec_query_optimizer_info

```sql
SELECT  deqoi.counter,
		deqoi.occurrence,
		deqoi.value
FROM sys.dm_exec_query_optimizer_info AS deqoi;
```

Частичный набор результатов запроса показан на рис. 2-8.

![[Figure 2-8.png]]

Видно, что в системе, на которой я работал, было сделано очень мало сложных оптимизаций. Это видно по отсутствию операций Search 2. Вы можете увидеть другие операции, которые были выполнены, и предполагаемое время, необходимое для их выполнения.  
Эта информация имеет ограниченное применение, но ее полезно знать, если вдруг понадобится понять, какие процессы выполняет оптимизатор и какую нагрузку он оказывает на систему.  
Можно также запустить этот код до и после выполнения запроса, чтобы увидеть, какие виды оптимизации были произведены в этом запросе. Однако это необходимо делать на изолированной системе, иначе вы, скорее всего, увидите не только оптимизацию для исследуемого запроса.  
#OptimizationPhases

## Генерация планов параллельного выполнения  
  
Когда планы становятся достаточно сложными, они могут получить преимущество от параллельного выполнения. Параллельное выполнение - это когда для SQL Server доступно более одного процессора, поэтому для выполнения одного запроса задействуется несколько процессоров. Однако параллельное выполнение является дорогостоящей операцией, поэтому необходимо, чтобы запрос получил выгоду от нее до того, как он перейдет к параллельному выполнению. На самом деле, некоторые запросы могут выполняться параллельно, но при этом они работают медленнее. Когда оптимизатор принимает решение о том, будет ли сложный запрос выполняться параллельно, он  
учитывает ряд факторов: 

- процессоры, доступные SQL Server, если их несколько  
- редакция SQL Server  
- доступная память  
- Пороговая стоимость параллелизма  
- Выполняемый запрос  
- Строки, подлежащие обработке  
- Активные параллельные соединения  
- Максимальная степень параллелизма 

Три наиболее важных из этих факторов - фактическое количество CPU, доступных SQL Server, максимальная степень параллелизма и порог стоимости параллелизма.  
Если для SQL Server доступен только один процессор или один vCPU на узле NUMA, то ни один запрос не будет выполняться параллельно. Также можно ограничить параллелизм и количество используемых им процессоров с помощью параметра Max Degree of Parallelism. Если установить значение 1, то параллельное выполнение будет полностью исключено, но это не рекомендуется. Для управления параметром Max Degree of Parallelism необходимо использовать настройку сервера (Листинг 2-5).  

Листинг 2-5. Изменение максимальной степени параллелизма

```sql
USE master;

EXEC sp_configure 'show advanced option', '1';

RECONFIGURE;

EXEC sp_configure 'max degree of parallelism', 2;

RECONFIGURE;
```

Результат вступает в силу немедленно. Определение точного значения этой величины часто становится предметом серьезных споров. Эти решения должны принимать ваши системы и рабочие нагрузки, а не произвольные расчеты, основанные на количестве имеющихся в них процессоров. В связи с этим я не буду давать точного определения, а лишь еще раз подчеркну, что параллельное выполнение некоторых запросов очень желательно, поэтому вы должны оставить такую возможность в своих системах, то есть не устанавливайте значение Max Degree of Parallelism равным 1.  
Вы также можете управлять степенью параллельности для каждого запроса с помощью подсказок запроса. Я буду повторять это несколько раз в книге: использование подсказок запросов должно быть очень тщательно регламентировано в ваших системах. В листинге 2-6 показано, как это работает. 
#queryhint
  
Листинг 2-6. Управление степенью параллелизма с помощью подсказки запроса  

```sql
SELECT  e.ID,
		e.SomeValue
FROM dbo.Example AS e
WHERE e.ID = 42
OPTION (MAXDOP 2);
```

Если вы хотите непосредственно контролировать, какие планы идут параллельно, то лучшим способом является управление процессом путем изменения порога стоимости для параллелизма (Листинг 2-7). Значение по умолчанию, равное 5, является чрезвычайно низким для большинства систем. Microsoft, как правило, с этим не согласна, но я бы сразу сделал это значение выше. Опять же, точное значение зависит от вашей системы, запросов и нагрузки.  
  
Листинг 2-7. Изменение порога стоимости для параллелизма  

```sql
USE master;

EXEC sp_configure 'show advanced option', '1';

RECONFIGURE;

EXEC sp_configure 'cost threshold for parallelism', 35;

RECONFIGURE;
```

Одним из способов определения хорошего значения порога стоимости является анализ оценочной стоимости запросов в ваших системах. Используя любую из доступных метрик запросов и оценки стоимости по планам выполнения, можно увидеть, как ведут себя системы, и на основе этого внести коррективы.  
Как уже было сказано выше, параллельное выполнение запросов требует больших затрат. Параллельное выполнение занимает не только больше ресурсов процессора, но и значительно больше памяти. Поэтому перед выполнением параллельного плана SQL Server учитывает объем доступной памяти. SQL Server будет автоматически уменьшать количество параллелей или полностью отказываться от них для данного запроса на системе, находящейся под нагрузкой.  
Все DML-запросы выполняются последовательно. Однако запросы SELECT (в INSERT) и WHERE (в UPDATE или DELETE) могут выполняться параллельно. Все изменения данных по-прежнему выполняются последовательно, а не параллельно.  
Во время выполнения SQL Server может изменить поведение параллельного выполнения. Тогда он устанавливает число потоков обработки для данного запроса, и это число потоков используется на протяжении всего его выполнения. Это значение может быть пересмотрено при следующем выполнении запроса и может измениться.  
#parallelexecution #plan #parallel

## Кэширование плана выполнения  
  
Когда оптимизатор завершает свою работу, результатом является план выполнения. Этот план сохраняется в памяти SQL Server в месте, называемом кэшем плана. Сохранение плана в кэше - это еще одна оптимизация, которую выполняет SQL Server в попытке сделать запросы быстрее. Сохранив план, его можно использовать повторно, а не проходить процесс оптимизации заново. Однако планы могут быть удалены из кэша с помощью различных процессов. Один из таких процессов называется "устаревание".  
  
## Старение плана выполнения  
  
Кэш планов является частью буферного кэша SQL Server, в котором также хранятся страницы данных. По мере добавления новых планов выполнения в кэш планов его размер постоянно растет, что сказывается на сохранении в памяти полезных страниц данных. Чтобы избежать этого, SQL Server динамически управляет хранением планов выполнения в кэше планов, сохраняя часто используемые планы выполнения и отбрасывая планы, которые не используются в течение определенного периода времени.  
SQL Server отслеживает частоту повторного использования плана выполнения, связывая с ним поле age. Когда генерируется план выполнения, в поле "возраст" заносится стоимость генерации плана. Для сложного запроса, требующего глубокой оптимизации, значение поля age будет больше, чем для более простого запроса.  
Через регулярные промежутки времени текущая стоимость всех планов выполнения в кэше планов проверяется процессом SQL Server lazy writer (который управляет большинством фоновых процессов в SQL Server). Если план выполнения не используется повторно в течение длительного времени, то его текущая стоимость в конце концов уменьшится до 0. Чем дешевле был сгенерирован план выполнения, тем быстрее его стоимость уменьшится до 0. Как только стоимость плана выполнения достигает 0, план становится кандидатом на удаление из памяти. SQL Server удаляет все планы со стоимостью 0 из кэша планов, когда нагрузка на память возрастает до такой степени, что свободной памяти уже не хватает для обслуживания новых запросов. Однако если в системе достаточно памяти и свободные страницы памяти доступны для обслуживания новых запросов, то планы выполнения со стоимостью 0 могут оставаться в кэше планов в течение длительного времени, чтобы впоследствии при необходимости их можно было использовать повторно.  
Помимо изменения стоимости в сторону уменьшения, планы выполнения могут также увеличивать свою стоимость до максимальной стоимости генерации плана при каждом повторном использовании плана (или до текущей стоимости плана для специальных планов). Например, предположим, что у вас есть два плана выполнения, стоимость генерации которых равна 100 и 10. Поэтому их начальные значения стоимости будут равны 100 и 10 соответственно. Если оба плана выполнения будут немедленно использованы повторно, то в их полях возраст будет установлен на максимальную стоимость. При таких значениях стоимости lazy writer снизит стоимость второго плана до 0 гораздо раньше, чем первого, если только второй план не будет использоваться чаще. Таким образом, даже если дорогостоящий план используется реже, чем более дешевый, из-за эффекта начальной стоимости дорогостоящий план может сохранять ненулевое значение стоимости в течение более длительного времени.  
#age #AgePlan

## Заключение  
  
Хотя для ускорения выполнения запросов не обязательно понимать все аспекты работы оптимизатора запросов, некоторое понимание этого процесса будет полезно. Вы увидели основной процесс, который проходит оптимизатор, начиная с разбора и связывания, заканчивая согласованием тривиальных планов и, наконец, полным процессом оптимизации. Мы также обсудили некоторые принципы работы параллельных планов и способы, с помощью которых планы выполнения оказываются в кэше планов.  
В следующей главе мы рассмотрим наилучшие способы получения показателей производительности запросов.