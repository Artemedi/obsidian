В этой серии статей мы будем изучать планы выполнения SQL Server, начиная с определения понятия планов выполнения, затем рассмотрим типы, компоненты и операторы планов выполнения, проанализируем планы выполнения, и завершим рассмотрением способов сохранения и управления планами выполнения.

Когда вы отправляете запрос на языке T-SQL, вы сообщаете SQL Server Engine, что вы хотите получить, но не указываете, как это сделать. Между отправкой запроса на языке T-SQL в SQL Server Database Engine и возвратом результата запроса пользователю SQL Server Engine выполняет четыре внутренние операции обработки запроса, чтобы преобразовать запрос в формат, который может быть легко использован SQL Server Storage Engine для извлечения запрошенных данных, используя процессы, назначенные SQL Engine из операционной системы для работы с отправленным запросом.

Первые три процесса - разбор (**Parser**), алгебризация (**Algebrizing**) и оптимизация (**Optimizing**) - выполняются SQL Server Relational Engine. С другой стороны, этап выполнения выполняется SQL Server Storage Engine. Если отправленный запрос не является оператором языка манипулирования данными ([DML]('https://en.wikipedia.org/wiki/Data_manipulation_language')), таким как CREATE TABLE или ALTER TABLE, то нет необходимости оптимизировать этот запрос, так как у SQL Server Engine есть только один прямой способ выполнить это действие. Четыре этапа обработки, которые выполняются как SQL Server Relational Engine, так и SQL Server Storage Engine, можно суммировать следующим образом:

![[Plan_1.png]]


Когда SQL-запрос отправляется, он разбивается на отдельные части и проверяется SQL Server Relational Engine, чтобы убедиться, что он написан правильно, без ошибок синтаксиса, например, в рамках процесса, называемого разбором запроса (**Query Parsing**). Результатом процесса разбора запроса является дерево разбора (**Parsing tree**). Дерево разбора - это внутреннее представление запроса, которое включает все шаги, также известные как операции предварительного выполнения, которые выполняются для выполнения предоставленного запроса. После создания дерева разбора для запросов DML алгебризатор (**Algebrizing**) будет брать сгенерированное дерево и разрешать имена различных объектов базы данных, на которые ссылается отправленный запрос, в системном каталоге, чтобы убедиться, что эти объекты существуют в базе данных и что у пользователя есть разрешение на выполнение запроса. Алгебризатор (**Algebrizing**) создаст дерево запроса, которое будет использоваться на следующем этапе, как показано ниже:

![[Plan_2.png]]

Результат обработки алгебризатором (**Algebrizing**) , дерево обработки запросов, будет входным для Query Optimizer для плана выполнения SQL Server. Query Optimizer - это функционал, который отвечает за моделирование работы SQL Server Relational Engine путем создания наиболее эффективного плана для выполнения предоставленного запроса с наименьшим потреблением ресурсов SQL Server - это называется планом выполнения на основе стоимости. Оптимизатор запросов (**Query Optimizer**) будет пытаться использовать различные способы выполнения, читая все строки таблицы, используя различные индексы, соединения и порядки и компромисс между различными сценариями потребления ресурсов, пока он не получит наиболее оптимальный план выполнения с минимальной возможной стоимостью. Общая стоимость каждого кандидатского плана выполнения рассчитывается путем присвоения веса каждой операции и суммирования стоимости всех этих операций вместе.

План выполнения SQL Server (**Query Optimizer**) представляет собой двоичное представление шагов, которые будут выполнены SQL Server Engine для выполнения запроса. Другими словами, это наиболее эффективная и наименее затратная дорожная карта, сгенерированная оптимизатором запросов SQL Server, путем применения различных алгоритмов для выполнения представленного запроса. План будет создан на основе дерева обработчика запросов, полученного на этапе привязки, и статистики таблиц и индексов базы данных, которая описывает распределение и уникальность данных внутри объектов базы данных, при условии, что уровень оптимизации настроен как Полный (**Full**). Эта статистика помогает оптимизатору запросов SQL Server сравнить количество записей, возвращаемых при сканировании всех строк таблицы и при использовании различных индексов, с затратами каждой операции. Очень важно поддерживать актуальность статистики таблиц и индексов базы данных, чтобы можно было создавать наиболее оптимальные планы выполнения.

После выбора наиболее эффективного плана выполнения SQL Server для нового запроса он будет сохранен в памяти кэша планов (**Plan Cache**), который является частью буфера SQL Server, где хранятся планы запросов для последующего повторного использования. Это более эффективно, чем генерация нового плана при каждом выполнении. Это связано с тем, что создание наиболее оптимального плана выполнения является затратным процессом. При отправке нового запроса оптимизатор запросов SQL Server будет искать в кэше планов существующий план выполнения SQL Server для этого запроса, чтобы повторно использовать его. Если не найден план, который может быть повторно использован, оптимизатор запросов будет выполнять описанный ранее процесс создания нового плана, что займет больше времени на выполнение этого запроса. Повторное использование планов выполнения очень полезно в случае хранимых процедур, которые выполняются часто с разными параметрами, но все же используют один и тот же кэшированный план выполнения. Большое количество внезапных запросов в базе данных препятствует повторному использованию планов выполнения и требует непрерывного создания планов, что следует учитывать при настройке типа нагрузки, о чем мы подробно обсудим в этой серии.

В определенных ситуациях оптимизатор запросов SQL Server предпочитает создать базовый план, также известный как тривиальный (**Trivial**) план, для выполнения запросов, не содержащих агрегации или сложных вычислений, вместо того, чтобы тратить время и ресурсы на создание наиболее эффективного плана для этого запроса. После этого план выполнения будет запланирован и использован SQL Server Storage Engine на этапе выполнения (**Execution**) запроса в соответствии с выбранным планом и выполнит запрошенный процесс извлечения, вставки или изменения данных, как показано ниже:

![[Plan_3.png]]

Администраторы баз данных SQL Server часто полагаются на планы выполнения SQL Server при устранении проблем с производительностью запросов на языке T-SQL и поиске самых медленных частей. План выполнения также предоставляет администраторам баз данных ответы на различные вопросы, такие как почему запрос выполняется медленно и занимает много времени, потребляет большое количество ресурсов процессора, памяти или ввода-вывода, или почему данный индекс не используется в запросе. Кроме того, план выполнения помогает администраторам баз данных написать запросы более эффективным способом и выбрать наиболее подходящий и рекомендуемый индекс для ускорения извлечения данных. Чтобы использовать план выполнения для настройки производительности запросов, администратор базы данных должен обладать необходимыми навыками создания планов выполнения, понимания их различных типов и анализа их компонентов и операторов.

Теперь у нас ясное представление о том, что такое план выполнения SQL Server и как он генерируется внутренним образом оптимизатором запросов SQL Server. Мы готовы перейти к следующей статье этой серии, чтобы обсудить различные типы планов выполнения: фактические, предполагаемые или актуальные планы, а также графические, текстовые или XML-форматы. Готовьтесь к глубокому погружению в планы выполнения!

![[Plan_4.png]]